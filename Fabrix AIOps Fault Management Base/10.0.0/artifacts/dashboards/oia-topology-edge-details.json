{
    "name": "oia-topology-edge-details",
    "label": "Edge Details for Topology with alerts",
    "description": "Edge Details for Topology with alerts",
    "version": "26.1.5.1",
    "enabled": true,
    "exportable": false,
    "dashboard_style": "auto",
    "dashboard_type": "template",
    "template_variables": {
        "INCIDENT_CREATED_TIME": {
            "contextId": "i_created_ts",
            "default": "2026-01-05T09:39:36.265000"
        },
        "PROJECT_ID": {
            "default": null,
            "contextId": "projectid"
        },
        "INCIDENT_ID": {
            "default": null,
            "contextId": "incidentid"
        },
        "LEFT_ID": {
            "default": null,
            "contextId": "source"
        },
        "RIGHT_ID": {
            "default": null,
            "contextId": "target"
        },
        "EDGE_TYPE": {
            "default": null,
            "contextId": "edgeType"
        },
        "displayAttributes": {
            "default": null,
            "contextId": "displayAttributes"
        }
    },
    "custom_context": {
        "alert-context": true
    },
    "dashboard_filters": {
        "time_filter": false,
        "default_time_range": {
            "from_time": "{{INCIDENT_CREATED_TIME}}",
            "from_time_delta_hours": -0.5,
            "to_time": "{{INCIDENT_CREATED_TIME}}",
            "to_time_delta_hours": 0.5,
            "label": "Time Range"
        },
        "columns_filter": [],
        "extra_filter": "a_source_systemname is not-in 'Alert Group' and a_correlation_status not-in 'AGGREGATE' and project_id is '{{PROJECT_ID}}'"
    },
    "import": [
        {
            "from": "oia-alerts-os",
            "as": "alerts"
        }
    ],
    "dashboard_sections": [
        {
            "title": "Edge Details",
            "show_filter": true,
            "widgets": [
                {
                    "widget_type": "custom_widget",
                    "widget_implementation": "oia-topology-edge-details/edge_detail_widget",
                    "max_width": 12,
                    "height": 1.25,
                    "min_width": 12,
                    "widget_id": "182229d8"
                }
            ]
        }
    ],
    "custom_widgets": {
        "edge_detail_widget": {
            "artifacts": {
                "main": {
                    "attachment": "edge_details",
                    "content_type": "text/html",
                    "is_template": true
                }
            }
        }
    },
    "saved_time": "2026-01-05T11:28:06.214839",
    "attachments": [
        {
            "name": "edge_details",
            "value": "<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\r\n    <title>Nodes with Multiple Edges and Interfaces</title>\r\n    <script src=\"https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js\"></script>\r\n    <script>\r\n        // =============================================================================\r\n        // CONFIGURATION - Modify these settings as needed\r\n        // =============================================================================\r\n        \r\n        // Set to false when using real API data, true for testing with sample data\r\n        const TEST_MODE = false;\r\n        \r\n        // Map relationship properties to edge labels\r\n        // Use lodash path syntax for nested properties: \"displayAttributes[0].value\"\r\n        const attributeMap = {\r\n            \"nodeLabel\": \"node_label\",\r\n            \"nodeIcon\": \"node_type\",\r\n            \"edgeCenterLabel\": \"link_type\",\r\n            \"edgeSourceLabel\": \"source_interface_name\",\r\n            \"edgeDestLabel\": \"dest_interface_name\",\r\n            \"edgeColor\": \"edge_color\",\r\n            \"edgeSourceLabelColor\": \"source_label_outline_color\",\r\n            \"edgeDestLabelColor\": \"dest_label_outline_color\"\r\n        }\r\n        \r\n        // =============================================================================\r\n        // END CONFIGURATION\r\n        // =============================================================================\r\n    </script>\r\n    <style>\r\n        * {\r\n            margin: 0;\r\n            padding: 0;\r\n            box-sizing: border-box;\r\n        }\r\n\r\n        html {\r\n            height: 100%;\r\n            width: 100%;\r\n        }\r\n\r\n        body {\r\n            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;\r\n            background-color: #f5f5f5;\r\n            overflow: hidden;\r\n            height: 100%;\r\n            width: 100%;\r\n        }\r\n\r\n        .container {\r\n            width: 100%;\r\n            height: 100%;\r\n            display: flex;\r\n            justify-content: center;\r\n            align-items: center;\r\n        }\r\n\r\n        .graph-container {\r\n            width: 100%;\r\n            height: 100%;\r\n            background-color: white;\r\n            border: 1px solid #ddd;\r\n            border-radius: 8px;\r\n            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: space-between;\r\n            padding: 20px;\r\n            box-sizing: border-box;\r\n\r\n            overflow-x: auto;\r\n        }\r\n\r\n        .node {\r\n            height: 100px;\r\n            display: flex;\r\n            flex-direction: column;\r\n            align-items: center;\r\n            justify-content: center;\r\n            transition: all 0.2s ease;\r\n            flex-shrink: 0;\r\n            min-width: 80px;\r\n        }\r\n\r\n        .node-circle {\r\n            width: 60px;\r\n            height: 60px;\r\n            background-color: #e3f2fd;\r\n            border: 2px solid #1976d2;\r\n            border-radius: 50%;\r\n            display: flex;\r\n            align-items: center;\r\n            justify-content: center;\r\n            transition: all 0.2s ease;\r\n            padding: 10px;\r\n        }\r\n\r\n        .node-circle img {\r\n            height: 100%;\r\n            width: 100%;\r\n        }\r\n\r\n        .node-label {\r\n            font-size: 14px;\r\n            font-weight: bold;\r\n            color: #333;\r\n            margin-top: 8px;\r\n            text-align: center;\r\n\r\n            width: 150px;\r\n            height: 40px;\r\n            word-break: break-word;\r\n        }\r\n\r\n        .edges-container {\r\n            display: flex;\r\n            align-items: stretch;\r\n            flex: 1;\r\n            margin: 0 20px;\r\n\r\n            min-width: 300px;\r\n        }\r\n\r\n        .parallel-line {\r\n            width: 4px;\r\n            background-color: #1976d2;\r\n            border-radius: 2px;\r\n            flex-shrink: 0;\r\n        }\r\n\r\n        .edges {\r\n            display: flex;\r\n            flex-direction: column;\r\n            justify-content: space-around;\r\n            flex: 1;\r\n            margin: 0 10px;\r\n            min-width: 0;\r\n        }\r\n\r\n        .edge {\r\n            display: flex;\r\n            align-items: center;\r\n            position: relative;\r\n            height: 40px;\r\n            margin: 5px 0;\r\n        }\r\n\r\n        .edge-line {\r\n            flex: 1;\r\n            height: 2px;\r\n            background-color: #666;\r\n            position: relative;\r\n            margin-right: 8px;\r\n            min-width: 0;\r\n        }\r\n\r\n        .edge.dotted .edge-line {\r\n            background: repeating-linear-gradient(\r\n                to right,\r\n                #666 0px,\r\n                #666 8px,\r\n                transparent 8px,\r\n                transparent 16px\r\n            );\r\n        }\r\n\r\n        .arrow {\r\n            width: 0;\r\n            height: 0;\r\n            position: absolute;\r\n            top: 50%;\r\n            transform: translateY(-50%);\r\n        }\r\n\r\n        .arrow.right {\r\n            border-left: 8px solid #666;\r\n            border-top: 6px solid transparent;\r\n            border-bottom: 6px solid transparent;\r\n            right: -2px;\r\n        }\r\n\r\n        .arrow.left {\r\n            border-right: 8px solid #666;\r\n            border-top: 6px solid transparent;\r\n            border-bottom: 6px solid transparent;\r\n            left: -2px;\r\n        }\r\n\r\n        .edge-label {\r\n            position: absolute;\r\n            top: -2px;\r\n            left: 50%;\r\n            transform: translateX(-50%);\r\n            font-size: 12px;\r\n            color: #333;\r\n            white-space: nowrap;\r\n        }\r\n\r\n        .interface-label {\r\n            position: absolute;\r\n            padding: 2px 6px;\r\n            border-radius: 4px;\r\n            font-size: 10px;\r\n            color: #1976d2;\r\n            border: 1px solid currentColor;\r\n            background-color: color-mix(in srgb, currentColor 10%, transparent);\r\n            white-space: nowrap;\r\n            font-weight: 500;\r\n\r\n            /* width */\r\n            max-width: 120px;\r\n            text-overflow: ellipsis;\r\n            overflow: hidden;\r\n            white-space: nowrap;\r\n        }\r\n\r\n        .interface-label.left {\r\n            left: 10px;\r\n            top: -4px;\r\n        }\r\n\r\n        .interface-label.right {\r\n            right: 20px;\r\n            top: -4px;\r\n        }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"graph-container\" id=\"graph-container\">\r\n            <!-- Edges Container -->\r\n            <div class=\"edges-container\">\r\n                <!-- Left Parallel Line -->\r\n                <div class=\"parallel-line\" id=\"left-line\"></div>\r\n\r\n                <!-- Edges -->\r\n                <div class=\"edges\" id=\"edges\">\r\n                    <!-- Edges will be dynamically added here -->\r\n                </div>\r\n\r\n                <!-- Right Parallel Line -->\r\n                <div class=\"parallel-line\" id=\"right-line\"></div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <script id=\"context-data\" type=\"application/json\">\r\n        {{ all_variables.get(\"context\") | tojson }}\r\n    </script>\r\n\r\n    <script>\r\n        // Sample data based on your structure\r\n        const data = {\r\n            components: [\r\n                { node_label: 'linux-mysql-db01', node_id: 'left-node' },\r\n                { node_label: 'win2012-dynatrace-template-dnd', node_id: 'right-node' }\r\n            ],\r\n            relationships: [\r\n                { \r\n                    id: '1', \r\n                    left_id: 'left-node', \r\n                    right_id: 'right-node', \r\n                    relation_type: 'Edge Label 1', \r\n                    link_type: \"OSPF\",\r\n                    // edge_color: \"#FF5733\",\r\n                    source_label_outline_color: \"#FF5733\",\r\n                    dest_label_outline_color: \"#C70039\",\r\n                    displayAttributes: [\r\n                        {\r\n                            \"key\": \"source_interface_name\",\r\n                            \"value\": \"ethernet_port\"\r\n                        },\r\n                        {\r\n                            \"key\": \"dest_interface_name\",\r\n                            \"value\": \"ethernet_port\"\r\n                        }\r\n                    ],\r\n                    dotted: false\r\n                },\r\n                { \r\n                    id: '2', \r\n                    left_id: 'right-node', \r\n                    right_id: 'left-node', \r\n                    relation_type: 'Edge Label 2',\r\n                    link_type: \"CDP\",\r\n                    edge_color: \"#33C1FF\",\r\n                    source_label_outline_color: \"#0066CC\",\r\n                    dest_label_outline_color: \"#33C1FF\",\r\n                    displayAttributes: [\r\n                        {\r\n                            \"key\": \"source_interface_name\",\r\n                            \"value\": \"serial_port\"\r\n                        },\r\n                        {\r\n                            \"key\": \"dest_interface_name\",\r\n                            \"value\": \"ethernet_port\"\r\n                        }\r\n                    ],\r\n                    dotted: true\r\n                },\r\n                { \r\n                    id: '3', \r\n                    left_id: 'left-node', \r\n                    right_id: 'right-node', \r\n                    relation_type: 'Edge Label 3', \r\n                    link_type: \"BGP\",\r\n                    edge_color: \"#28A745\",\r\n                    source_label_outline_color: \"#28A745\",\r\n                    dest_label_outline_color: \"#155724\",\r\n                    displayAttributes: [\r\n                        {\r\n                            \"key\": \"source_interface_name\",\r\n                            \"value\": \"serial_port\"\r\n                        },\r\n                        {\r\n                            \"key\": \"dest_interface_name\",\r\n                            \"value\": \"serial_port\"\r\n                        }\r\n                    ],\r\n                    dotted: false,\r\n                    is_directionless: true\r\n                },\r\n                { \r\n                    id: '4', \r\n                    left_id: 'right-node', \r\n                    right_id: 'left-node', \r\n                    relation_type: 'Edge Label 4', \r\n                    link_type: \"LLDP\",\r\n                    displayAttributes: [\r\n                        {\r\n                            \"key\": \"source_interface_name\",\r\n                            \"value\": \"ethernet_port\"\r\n                        },\r\n                        {\r\n                            \"key\": \"dest_interface_name\",\r\n                            \"value\": \"ethernet_port\"\r\n                        }\r\n                    ],\r\n                    dotted: true\r\n                }\r\n            ]\r\n        };\r\n\r\n        // get context from jinja all_variables (parsed from JSON script tag)\r\n        const context = (() => {\r\n            const el = document.getElementById(\"context-data\");\r\n            if (!el) return null;\r\n            try { return JSON.parse(el.textContent || \"null\"); } catch { return null; }\r\n        })();\r\n        let LHSNodeId, RHSNodeId;\r\n        \r\n        // Get icon map from parent window\r\n        const iconMap = window.parent?.cfxIconMap || {};\r\n        console.log(\"MSB context\", context)\r\n        console.log(\"MSB iconMap from parent\", iconMap)\r\n\r\n        const setContextToApiEndpoint = (api_endpoint) => {\r\n            if(!context){\r\n                throw new Error(\"No context found\");\r\n            }\r\n            LHSNodeId = context?.displayAttributes?.find(attr => attr.key === \"left_id\")?.value;\r\n            RHSNodeId = context?.displayAttributes?.find(attr => attr.key === \"right_id\")?.value;\r\n\r\n            if(!LHSNodeId || !RHSNodeId){\r\n                throw new Error(\"No left or right id found\");\r\n            }\r\n            api_endpoint.serviceRequestDescriptor.params.params[0].context = context;\r\n            api_endpoint.serviceRequestDescriptor.params.params[0].context.node_list = [\r\n                {\r\n                    \"node_id\": LHSNodeId\r\n                },\r\n                {\r\n                    \"node_id\": RHSNodeId\r\n                }\r\n            ]\r\n            api_endpoint.serviceRequestDescriptor.params.params[0].stack_type = \"dynamic\";\r\n            api_endpoint.serviceRequestDescriptor.params.params[0].stack_definition = api_endpoint.serviceRequestDescriptor.params.params[0].context.stack_definition;\r\n            if(api_endpoint.serviceRequestDescriptor.params.params[0].context.name){\r\n                delete api_endpoint.serviceRequestDescriptor.params.params[0].context.name;\r\n            }\r\n        }\r\n        async function fetchData() {\r\n            const api_url = \"/api/portal/rdac/browseapi\";\r\n            const api_endpoint = {\r\n                serviceRequestDescriptor: {\r\n                    \"serviceName\": \"saas-reports\",\r\n                    \"version\": \"*\",\r\n                    \"params\": {\r\n                    \"params\": [\r\n                        {\r\n                            \"dashboardId\": \"Topology\",\r\n                            \"reportId\": \"rda.saas.stack.view.topo\"\r\n                        }\r\n                    ]\r\n                    },\r\n                    \"methodName\": \"getReport\",\r\n                    \"ignoreCall\": true,\r\n                    \"parseOutput\": true\r\n                }\r\n            };\r\n            setContextToApiEndpoint(api_endpoint);\r\n            try {\r\n                console.log(\"MSB Making request to\", api_url, api_endpoint)\r\n                const response = await fetch(api_url, {\r\n                method: \"POST\",\r\n                body: JSON.stringify(api_endpoint),\r\n                headers: {\r\n                    \"Content-Type\": \"application/json\",\r\n                },\r\n                });\r\n                const data = await response.json();\r\n                return data.serviceResult?.data?.dataFlowGraph;\r\n            } catch (error) {\r\n                console.error(\"Fetch error:\", error);\r\n                appendErrorText(\"Failed to fetch data\");\r\n            }\r\n        }\r\n\r\n        // Create nodes\r\n        function createNodes(components) {\r\n            const container = document.getElementById('graph-container');\r\n            \r\n            // Clear existing nodes\r\n            const existingNodes = container.querySelectorAll('.node');\r\n            existingNodes.forEach(node => node.remove());\r\n            \r\n            // Find LHS and RHS nodes by their IDs\r\n            const lhsNode = components.find(component => component.node_id === LHSNodeId);\r\n            const rhsNode = components.find(component => component.node_id === RHSNodeId);\r\n\r\n            if (!lhsNode || !rhsNode) {\r\n                console.error('LHS or RHS node not found in components');\r\n                return;\r\n            }\r\n            \r\n            // Create left node (LHS)\r\n            const leftNodeDiv = document.createElement('div');\r\n            leftNodeDiv.className = 'node';\r\n            leftNodeDiv.id = 'node-a';\r\n            const leftNodeLabel = _.get(lhsNode, attributeMap.nodeLabel) || 'Node A';\r\n            const leftNodeIcon = _.get(lhsNode, attributeMap.nodeIcon, '');\r\n\r\n            let leftNodeIconSrc;\r\n            if(leftNodeIcon?.startsWith('http')){\r\n                leftNodeIconSrc = leftNodeIcon;\r\n            }else {\r\n                leftNodeIconSrc = iconMap[leftNodeIcon] ? \"/\" + iconMap[leftNodeIcon] : '/assets/img/blueprints/canvas/empty_icon.png';\r\n            }\r\n            leftNodeDiv.innerHTML = `\r\n                <div class=\"node-circle\">\r\n                    <img src=\"${leftNodeIconSrc}\" />\r\n                </div>\r\n                <div class=\"node-label\">${leftNodeLabel}</div>\r\n            `;\r\n            container.insertBefore(leftNodeDiv, container.querySelector('.edges-container'));\r\n            \r\n            // Create right node (RHS)\r\n            const rightNodeDiv = document.createElement('div');\r\n            rightNodeDiv.className = 'node';\r\n            rightNodeDiv.id = 'node-b';\r\n            const rightNodeLabel = _.get(rhsNode, attributeMap.nodeLabel) || 'Node B';\r\n            const rightNodeIcon = _.get(rhsNode, attributeMap.nodeIcon, '');\r\n            let rightNodeIconSrc;\r\n            if(rightNodeIcon?.startsWith('http')){\r\n                rightNodeIconSrc = rightNodeIcon;\r\n            }else {\r\n                rightNodeIconSrc = iconMap[rightNodeIcon] ? \"/\" + iconMap[rightNodeIcon] : '/assets/img/blueprints/canvas/empty_icon.png';\r\n            }\r\n            rightNodeDiv.innerHTML = `\r\n                <div class=\"node-circle\">\r\n                    <img src=\"${rightNodeIconSrc}\" />\r\n                </div>\r\n                <div class=\"node-label\">${rightNodeLabel}</div>\r\n            `;\r\n            container.appendChild(rightNodeDiv);\r\n\r\n            return  {\r\n                lhsNode,\r\n                rhsNode\r\n            }\r\n        }\r\n\r\n        /**\r\n         * Get key value from relationship object\r\n         * First tries _.get() with the key, then searches displayAttributes array\r\n         * Always returns a string (empty string if not found)\r\n         * @param {Object} relationship - The relationship object\r\n         * @param {string} attribute_map_key - The key to search for\r\n         * @returns {string} The value as a string, or empty string if not found\r\n         */\r\n        function getAttributeMapValue(relationship, attribute_map_key) {\r\n            // First try _.get() with the key\r\n            let value = _.get(relationship, attribute_map_key);\r\n            \r\n            // If we got a value (not undefined, null, or empty string), return it as string\r\n            if (value !== undefined && value !== null && value !== '') {\r\n                return String(value);\r\n            }\r\n            \r\n            // If not found, search in displayAttributes array\r\n            if (relationship.displayAttributes && Array.isArray(relationship.displayAttributes)) {\r\n                const displayAttr = relationship.displayAttributes.find(attr => attr.key === attribute_map_key);\r\n                if (displayAttr && displayAttr.value !== undefined && displayAttr.value !== null && displayAttr.value !== '') {\r\n                    return String(displayAttr.value);\r\n                }\r\n            }\r\n            \r\n            return '';\r\n        }\r\n\r\n        // Create edges\r\n        function createEdges(relationships) {\r\n            const edgesContainer = document.getElementById('edges');\r\n            \r\n            relationships.forEach((relationship) => {\r\n                // Create edge container\r\n                const edgeDiv = document.createElement('div');\r\n                edgeDiv.className = 'edge';\r\n                if (relationship.dotted) {\r\n                    edgeDiv.classList.add('dotted');\r\n                }\r\n\r\n                // Get edge color from relationship data, default to #666\r\n                const edgeColor = getAttributeMapValue(relationship, attributeMap.edgeColor) || '#666';\r\n\r\n                // Create edge line\r\n                const edgeLine = document.createElement('div');\r\n                edgeLine.className = 'edge-line';\r\n                \r\n                // Apply edge color\r\n                if (relationship.dotted) {\r\n                    edgeLine.style.background = `repeating-linear-gradient(\r\n                        to right,\r\n                        ${edgeColor} 0px,\r\n                        ${edgeColor} 8px,\r\n                        transparent 8px,\r\n                        transparent 16px\r\n                    )`;\r\n                } else {\r\n                    edgeLine.style.backgroundColor = edgeColor;\r\n                }\r\n\r\n                // Create arrow - determine direction based on relationship's left_id and right_id\r\n                // Compare relationship direction with LHSNodeId (left side) and RHSNodeId (right side)\r\n                // Arrow points right if relationship goes from LHS to RHS\r\n                // Arrow points left if relationship goes from RHS to LHS\r\n                const arrow = document.createElement('div');\r\n                // relationship.left_id = source, relationship.right_id = destination\r\n                // If source is RHS and destination is LHS, arrow points left\r\n                const isRightToLeft = relationship.left_id === RHSNodeId && relationship.right_id === LHSNodeId;\r\n                arrow.className = `arrow ${isRightToLeft ? 'left' : 'right'}`;\r\n                \r\n                // Apply arrow color based on direction\r\n                if (isRightToLeft) {\r\n                    arrow.style.borderRightColor = edgeColor;\r\n                } else {\r\n                    arrow.style.borderLeftColor = edgeColor;\r\n                }\r\n\r\n                // Create edge label\r\n                const edgeLabel = document.createElement('div');\r\n                edgeLabel.className = 'edge-label';\r\n                edgeLabel.textContent = getAttributeMapValue(relationship, attributeMap.edgeCenterLabel);\r\n\r\n                // Get source and destination interface values\r\n                const sourceInterfaceValue = getAttributeMapValue(relationship, attributeMap.edgeSourceLabel);\r\n                const destInterfaceValue = getAttributeMapValue(relationship, attributeMap.edgeDestLabel);\r\n                \r\n                // Get outline colors for labels, default to #1976d2\r\n                const sourceLabelColor = getAttributeMapValue(relationship, attributeMap.edgeSourceLabelColor) || '#1976d2';\r\n                const destLabelColor = getAttributeMapValue(relationship, attributeMap.edgeDestLabelColor) || '#1976d2';\r\n\r\n                // Create source interface label - position based on direction\r\n                // If arrow goes right (LHS -> RHS), source is on left\r\n                // If arrow goes left (RHS -> LHS), source is on right\r\n                let sourceInterfaceLabel;\r\n                if(sourceInterfaceValue){\r\n                    sourceInterfaceLabel = document.createElement('p');\r\n                    sourceInterfaceLabel.title = sourceInterfaceValue;\r\n                    sourceInterfaceLabel.className = `interface-label ${isRightToLeft ? 'right' : 'left'}`;\r\n                    sourceInterfaceLabel.textContent = sourceInterfaceValue;\r\n                    sourceInterfaceLabel.style.color = sourceLabelColor;\r\n                }\r\n\r\n                // Create destination interface label - position based on direction\r\n                // If arrow goes right (LHS -> RHS), destination is on right\r\n                // If arrow goes left (RHS -> LHS), destination is on left\r\n                let destInterfaceLabel;\r\n                if(destInterfaceValue){\r\n                    destInterfaceLabel = document.createElement('p');\r\n                    destInterfaceLabel.title = destInterfaceValue;\r\n                    destInterfaceLabel.className = `interface-label ${isRightToLeft ? 'left' : 'right'}`;\r\n                    destInterfaceLabel.textContent = destInterfaceValue;\r\n                    destInterfaceLabel.style.color = destLabelColor;\r\n                }\r\n                // Assemble edge\r\n                if(!relationship.is_directionless){\r\n                    edgeLine.appendChild(arrow);\r\n                }\r\n                edgeDiv.appendChild(edgeLine);\r\n                edgeDiv.appendChild(edgeLabel);\r\n                if(sourceInterfaceLabel){\r\n                    edgeDiv.appendChild(sourceInterfaceLabel);\r\n                }\r\n                if(destInterfaceLabel){\r\n                    edgeDiv.appendChild(destInterfaceLabel);\r\n                }      \r\n                edgesContainer.appendChild(edgeDiv);\r\n            });\r\n        }\r\n\r\n\r\n        // Initialize the graph\r\n        async function init() {\r\n            if(TEST_MODE){\r\n                LHSNodeId = data.components[0].node_id;\r\n                RHSNodeId = data.components[1].node_id;\r\n                createNodes(data.components);\r\n                createEdges(data.relationships);\r\n                return;\r\n            }\r\n            try {\r\n                const data = await fetchData();\r\n                const relationships = data?.relationships;\r\n                const components = data?.components;\r\n\r\n                if (!relationships || relationships?.length === 0) {\r\n                    throw new Error(\"No data to display\");\r\n                    return;\r\n                }\r\n\r\n                // filter out edges/relationships\r\n                // Child relationships may have different direction than parent relationship\r\n                // So we need to check both directions: LHS->RHS and RHS->LHS\r\n                // relationship.left_id = source node id, relationship.right_id = destination node id\r\n                const filteredRelationships = relationships.filter(relationship => {\r\n                    // Check if relationship matches parent direction (LHSNodeId -> RHSNodeId)\r\n                    const matchesParentDirection = relationship.left_id === LHSNodeId && relationship.right_id === RHSNodeId;\r\n                    // Check if relationship is in opposite direction (RHSNodeId -> LHSNodeId)\r\n                    const matchesOppositeDirection = relationship.left_id === RHSNodeId && relationship.right_id === LHSNodeId;\r\n                    return matchesParentDirection || matchesOppositeDirection;\r\n                })\r\n\r\n                const nodesResult = createNodes(components);\r\n                if (!nodesResult) {\r\n                    throw new Error(\"LHS or RHS node not found in components\");\r\n                }\r\n                const { lhsNode, rhsNode } = nodesResult;\r\n                createEdges(filteredRelationships);\r\n\r\n                console.log(\"MSB data\", filteredRelationships, lhsNode, rhsNode)\r\n            } catch (error) {\r\n                console.error(\"Fetch error:\", error);\r\n            }\r\n        }\r\n\r\n        // Start the application\r\n        init();\r\n    </script>\r\n</body>\r\n</html>",
            "additionalFields": {
                "valueType": "",
                "description": ""
            }
        }
    ]
}
