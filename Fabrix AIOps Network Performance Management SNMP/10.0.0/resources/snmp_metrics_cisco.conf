[[inputs.snmp]]
## add agents 
## Example: agents = ["udp://10.95.158.1:161","udp://10.95.158.9:161"]
agents = []
community = "public"
##community = "cisco"

## Timeout for each request.
timeout = "15s"
## Number of retries to attempt.
retries = 1
tags = {asset_type = "network_device", vendor = "Cisco", input = "SNMP", kpi_metric = "yes"}

[[inputs.snmp.field]]
   name = "sys_name"
   oid = "SNMPv2-MIB::sysName.0"
    is_tag = true

[[inputs.snmp.field]]
   name = "uptime"
   oid = "DISMAN-EVENT-MIB::sysUpTimeInstance"
[[inputs.snmp.field]]
   name = "device_product"
   oid = "iso.3.6.1.4.1.9.9.402.1.3.1.2.1"
[[inputs.snmp.field]]
   name = "device_software"
   oid = "iso.3.6.1.4.1.9.9.500.1.2.1.1.8.1001"

#Temps
[[inputs.snmp.table]]
   # ciscoEnvMonTemperatureStatusTable
   name = "environmental_temperature"
   inherit_tags = ["asset_type", "vendor", "input", "sys_name"," sys_location", "kpi_metric"]
[[inputs.snmp.table.field]]
   # ciscoEnvMonTemperatureStatusDescr
   name = "temperature_status_descr"
   oid = "iso.3.6.1.4.1.9.9.13.1.3.1.2"
[[inputs.snmp.table.field]]
   # ciscoEnvMonTemperatureStatusValue
   name = "temperature_status_value"
   oid = "iso.3.6.1.4.1.9.9.13.1.3.1.3"
[[inputs.snmp.table.field]]
   # ciscoEnvMonTemperatureThreshold
   name = "temperature_threshold"
   oid = "iso.3.6.1.4.1.9.9.13.1.3.1.4"
[[inputs.snmp.table.field]]
   # ciscoEnvMonTemperatureLastShutdown
   name = "temperature_last_shutdown"
   oid = "iso.3.6.1.4.1.9.9.13.1.3.1.5"
[[inputs.snmp.table.field]]
  # ciscoEnvMonTemperatureState
  name = "temperature_state"
  oid = "iso.3.6.1.4.1.9.9.13.1.3.1.6"

#CPU
[[inputs.snmp.table]]
  name = "cpu"
  inherit_tags = ["asset_type", "vendor", "input", "sys_name","sys_location", "kpi_metric"]
[[inputs.snmp.table.field]]
  name = "cpu_total_5sec_rev"
  oid = ".1.3.6.1.4.1.9.9.109.1.1.1.1.6"
[[inputs.snmp.table.field]]
  name = "cpu_total_1min_rev"
  oid = ".1.3.6.1.4.1.9.9.109.1.1.1.1.7"
[[inputs.snmp.table.field]]
  name = "cpu_total_5min_rev"
  oid = ".1.3.6.1.4.1.9.9.109.1.1.1.1.8"

## Creating a generic field cpu_usage for CPU metric
[[processors.starlark]]
  source = '''
def apply(metric):
    # Ensure both mem_usage and mem_total are present
    cpu_usage = metric.fields.get('cpu_total_5min_rev', 0)
    if cpu_usage == 0 or cpu_usage == None:
        return metric  # Skip the metric if value is missing or cpu_usage is 0
    # Update the metric with the new field
    metric.fields['cpu_usage'] = cpu_usage
    return metric
'''
[processors.starlark.tagpass]
  vendor = ["Cisco"]

#Cisco Memory
[[inputs.snmp.table]]
  name = "memory"
  inherit_tags = ["asset_type", "vendor", "input", "sys_name","sys_location", "kpi_metric"]
[[inputs.snmp.table.field]]
  name = "memory_pool_name"
  is_tag = true
  oid = ".1.3.6.1.4.1.9.9.48.1.1.1.2"
[[inputs.snmp.table.field]]
  name = "memory_pool_free"
  oid = ".1.3.6.1.4.1.9.9.48.1.1.1.6"
[[inputs.snmp.table.field]]
  name = "memory_pool_used"
  oid = ".1.3.6.1.4.1.9.9.48.1.1.1.5"

## Creating a generic field memory_usage for Memory metric
[[processors.starlark]]
  source = '''
def apply(metric):
   # Ensure both mem_usage and mem_total are present
    mem_usage = metric.fields.get('memory_pool_used', 0)
    mem_free = metric.fields.get('memory_pool_free', 0)
    mem_total = mem_usage + mem_free
    if mem_usage == None or mem_free == None or mem_total == 0:
        return metric  # Skip the metric if any value is missing or mem_total is 0
    # Calculate the percentage of used memory
    mem_percent = ((mem_usage / mem_total) * 100)
    # Update the metric with the new field
    metric.fields['memory_usage'] = mem_percent
    return metric
'''
[processors.starlark.tagpass]
  vendor = ["Cisco"]


#Cisco Voltage
[[inputs.snmp.table]]
 # ciscoEnvMonVoltageStatus
  name = "environmental_voltage"
  inherit_tags = ["asset_type", "vendor", "input", "sys_name","sys_location", "kpi_metric"]
[[inputs.snmp.table.field]]
  name = "voltage_status_descr"
  oid = ".1.3.6.1.4.1.9.9.13.1.2.1.2"
[[inputs.snmp.table.field]]
  name = "voltage_status_value"
  oid = ".1.3.6.1.4.1.9.9.13.1.2.1.3"
[[inputs.snmp.table.field]]
  name = "voltage_state"
  oid = ".1.3.6.1.4.1.9.9.13.1.2.1.7"

#Interface Stats
[[inputs.snmp.table]]
name = "interface"
inherit_tags = [ "vendor", "sys_name","sys_location", "kpi_metric"]
[[inputs.snmp.table.field]]
  name = "in_octets"
  oid = "IF-MIB::ifHCInOctets"
[[inputs.snmp.table.field]]
  name = "out_octets"
  oid = "IF-MIB::ifHCOutOctets"
[[inputs.snmp.table.field]]
  name = "description"
  oid = "IF-MIB::ifDescr"
  is_tag = true
[[inputs.snmp.table.field]]
  name = "interface_alias"
  oid = "IF-MIB::ifAlias"
  is_tag = true
[[inputs.snmp.table.field]]
  name = "high_speed"
  oid = "IF-MIB::ifHighSpeed"
[[inputs.snmp.table.field]]
  name = "oper_status"
  oid = "IF-MIB::ifOperStatus"
[[inputs.snmp.table.field]]
  name = "admin_status"
  oid = "IF-MIB::ifAdminStatus"
[[inputs.snmp.table.field]]
  name = "interface_index"
  oid = "IF-MIB::ifIndex"
  is_tag = true
[[inputs.snmp.table.field]]
  name = "interface_type"
  oid = "IF-MIB::ifType"
  is_tag = true
[[inputs.snmp.table.field]]
  name = "last_change"
  oid = "IF-MIB::ifLastChange"
[[inputs.snmp.table.field]]
  name = "in_errors"
  oid = "IF-MIB::ifInErrors"
[[inputs.snmp.table.field]]
  name = "out_errors"
  oid = "IF-MIB::ifOutErrors"
[[inputs.snmp.table.field]]
  name = "in_discards"
  oid = "IF-MIB::ifInDiscards"
[[inputs.snmp.table.field]]
  name = "out_discards"
  oid = "IF-MIB::ifOutDiscards"
[[inputs.snmp.table.field]]
  name = "if_speed"
  oid = "IF-MIB::ifSpeed"

  [inputs.snmp.tagdrop]
    interface_type = ["1","101","102","103","104","117","131","135","18","22","231","232","24","53","63","81","77"]

[[processors.enum]]
  namepass = ["interface"]
  [[processors.enum.mapping]]
    field = "oper_status"
    dest = "oper_status_label_check" 
    default = "unknown"
    [processors.enum.mapping.value_mappings]
      1 = "up"
      2 = "down"
      3 = "testing"
      4 = "unknown"
      5 = "dormant"
      6 = "notPresent"
      7 = "lowerLayerDown"


## Creating a generic tag metric name for each metric
##[[processors.starlark]]
##  source = '''
##def apply(metric):
##        # add new field metric_name
##    for key, value in metric.fields.items():
##           metric.tags['metric_name'] = key
##    return metric
##'''

[[processors.strings]]
  [[processors.strings.lowercase]]
  field_key = "*"
  [[processors.strings.lowercase]]
  measurement = "*"
  [[processors.strings.lowercase]]
  tag_key = "*"

##[[processors.rda_enrich]]
##  #dataset_name = "aia_asset_chassis_inventory_dict"
##  dataset_name = "network_devices_enrichment_dict"
##  refresh_interval = "60s"
##  enrich_column_defaults = ["Not Available", "Not Available", "Not Available",  "Not Available", "Not Available"]
##  dict_key_columns = ["additional_ips"]
##  source_key_columns = ["agent_host"]
##  enrich_columns = ["hostname","device_role","site_type","site_code","cafm_code"]
##  tagpass = { vendor = ["Cisco"] }


#Interface metrics delta calculation
[[processors.starlark]]
  source = '''
load("logging.star", "log")
load('time.star', 'time')
def round(value, decimals):
    factor = 1
    for _ in range(decimals):
        factor *= 10
    return int(value * factor) / factor
def max(a, b):
    if a > b:
        return a
    return b
def apply(metric):
    device_ip = metric.tags.get("agent_host", "")
    device_interface = metric.tags.get("description", "")
    if device_interface == "":
        device_interface = metric.tags.get("interface_index", "")

    if device_ip and device_interface:
        int_counter_metrics = ["in_octets",
                               "out_octets",
                               "in_discards",
                               "out_discards",
                               "in_errors",
                               "out_errors"]
        ##log.info("fields: {}".format(metric.fields))
        oper_status = metric.fields.get('oper_status')
        if oper_status == 1:
            oper_status_label = 'Up'
        elif oper_status == 2:
            oper_status_label = 'Down'
        else:
            oper_status_label = 'Unknown'
        metric.fields['oper_status_label'] = oper_status_label

        

        for item in metric.fields.keys():
            if item in int_counter_metrics:
                metric.fields["interface_utilization"] = 0
                key = device_ip + "_" + device_interface + "_" + item
                # Fetch previous values from state
                prev = state.get(key, None)
                prev_timestamp = state.get(key + "_timestamp", None)
                curr = metric.fields.get(item, None)
                if prev not in [None] and curr not in [None]:
                   metric.fields[item + "_delta"] = curr - prev
                # capture current time in seconds
                curr_timestamp = time.now().unix_nano / 1000000000
                if prev_timestamp not in [None]:
                    delt_in_octets = metric.fields.get("in_octets_delta", None)
                    delt_out_octets = metric.fields.get("out_octets_delta", None)
                    device_int_speed = metric.tags.get("device_int_speed", None)
                    if_speed = metric.fields.get("high_speed", None)
                    if if_speed not in [None]:
                        device_int_speed = if_speed * 1000000
                    # converting ifSpeed to int, sometimes getting value string
                    ##if type(device_int_speed) == "string" and device_int_speed != "CFX-Default":
                    ##    device_int_speed = int(device_int_speed)
                    ##else:
                    ##    # Skipping delta calculation due to invalid or missing ifSpeed metric
                    ##    continue
                    # interface utilization calculation
                    # ((((Delta_InOctets + Delta_OutOctets) * 8 / delta_time) / ifSpeed) * 100)
                    time_delta = curr_timestamp - prev_timestamp
                    metric.fields[item + "_time_delta"] = time_delta
                    if delt_in_octets not in [None] and delt_out_octets not in [None]:
                        if device_int_speed not in [None, 0] and time_delta not in [None]:
                            int_util = round(((max(delt_in_octets, delt_out_octets) * 8 / time_delta) / device_int_speed * 100), 2)
                            metric.fields["interface_utilization"] = int_util
                            input_util = round(((delt_in_octets * 8 / time_delta) / device_int_speed * 100), 2)
                            metric.fields["input_utilization"] = input_util
                            output_util = round((((delt_out_octets) * 8 / time_delta) / device_int_speed) * 100, 2)
                            metric.fields["output_utilization"] = output_util
                # Store new state for counter metrics
                state[key] = curr
                state[key + "_timestamp"] = curr_timestamp
   
    return metric
  '''
[processors.starlark.tagpass]
  vendor = ["Cisco"]


[[processors.starlark]]
  namepass = ["snmp"]
  source = '''
def apply(metric):
    if metric.fields.get("uptime", None):
        # Convert hundredths of a second to seconds
        uptime_seconds = int(metric.fields["uptime"]) / 100

        # Compute total minutes, hours, and days as integers
        total_minutes = int(uptime_seconds // 60)
        total_hours = int(uptime_seconds // 3600)
        total_days = int(uptime_seconds // 86400)

        # Remaining minutes and hours for breakdown
        minutes_only = total_minutes % 60
        hours_only = total_hours % 24
        days_only = total_days

        # Set fields as integers
        metric.fields["uptime_minutes"] = minutes_only
        metric.fields["uptime_hours"] = hours_only
        metric.fields["uptime_days"] = days_only
        metric.fields["uptime_readable"] = "{} days, {} hours, {} minutes".format(
            days_only, hours_only, minutes_only
        )

    return metric
'''

##name = "cisco_storage"

  [[inputs.snmp.table]]
    name = "hrStorageTable"
    oid = "1.3.6.1.2.1.25.2.3"  # HOST-RESOURCES-MIB::hrStorageTable

    [[inputs.snmp.table.field]]
      name = "hrStorageDescr"
      oid = "1.3.6.1.2.1.25.2.3.1.3"

    [[inputs.snmp.table.field]]
      name = "hrStorageAllocationUnits"
      oid = "1.3.6.1.2.1.25.2.3.1.4"

    [[inputs.snmp.table.field]]
      name = "hrStorageSize"
      oid = "1.3.6.1.2.1.25.2.3.1.5"

    [[inputs.snmp.table.field]]
      name = "hrStorageUsed"
      oid = "1.3.6.1.2.1.25.2.3.1.6"

    
