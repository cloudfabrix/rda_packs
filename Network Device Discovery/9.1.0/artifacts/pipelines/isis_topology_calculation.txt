%% stream = no and limit = 0

## ISIS Topology Calculation Pipeline
## Receives customer_tag via input dataset from parent pipeline (via @exec:run-pipeline)
## This pipeline processes ISIS (Intermediate System to Intermediate System) data to build network topology
@c:new-block
    --> @exec:get-input
    --> @dm:save name="temp-input-context"

## Get existing nodes from topology for label enrichment
## Nodes are queried once in main pipeline and passed to child pipelines
--> @c:new-block
    --> @dm:recall name="temp-input-context" and return_empty="yes"
    --> @dm:head n=1
    --> @dm:skip-block-if-shape row_count="0"
    --> *exec:if-condition topo_customer_tag is not empty and topo_customer_tag is not "None" and topo_customer_tag is not "none"
       --> @dm:eval dataset_name = "topo_customer_tag + '_topology_nodes'"
       --> @dm:save name="temp-dataset-config"
    --> @exec:end-if
    --> *exec:if-condition topo_customer_tag is empty or topo_customer_tag is "None" or topo_customer_tag is "none"
       --> @dm:recall name="topology_nodes" and return_empty="yes"
       --> *dm:safe-filter isis is 'yes'
       --> @dm:save name="temp-nodes"
       --> @dm:empty
       --> @dm:save name="temp-dataset-config"
    --> @exec:end-if

--> @c:new-block
    --> @dm:recall name="temp-dataset-config" and return_empty="yes"
    --> @dm:skip-block-if-shape row_count="0"

--> @c:data-loop dataset="temp-dataset-config" & columns="dataset_name"
    --> @dm:recall name="$dataset_name" and return_empty="yes"
    --> *dm:safe-filter isis is 'yes'
    --> @dm:save name="temp-nodes"

--> @c:new-block

--> @c:data-loop columns="topo_customer_tag" and dataset="temp-input-context" and return_empty="yes"
    --> @dm:recall name="temp-input-context" and return_empty="yes"
    --> @dm:head n=1
    --> @dm:skip-block-if-shape row_count="0"
    --> *exec:if-condition topo_customer_tag is not empty and topo_customer_tag is not "None" and topo_customer_tag is not "none"
       --> @dm:empty
       --> #dm:query-persistent-stream collection_status="Success" and profile contains "show_isis_neighbors" and parsed_json != "[]" and customer_tag = '$topo_customer_tag' with-input name="routing_protocol_data" & limit = "0"
       --> @dm:selectcolumns exclude = "raw_output"
       --> @dm:selectcolumns include="^parsed_json$|^source_ip$|^customer_tag$|^customer_id$"
       --> @dm:explode-json column="parsed_json"
       --> @dm:save name="temp-isis-output"
    --> @exec:end-if
    --> *exec:if-condition topo_customer_tag is empty or topo_customer_tag is "None" or topo_customer_tag is "none"
       --> @dm:empty
       --> #dm:query-persistent-stream collection_status="Success" and profile contains "show_isis_neighbors" and parsed_json != "[]" and (customer_tag is empty or customer_tag is 'None' or customer_tag is 'none') with-input name="routing_protocol_data" & limit = "0"
       --> @dm:selectcolumns exclude = "raw_output"
       --> @dm:selectcolumns include="^parsed_json$|^source_ip$|^customer_tag$|^customer_id$"
       --> @dm:explode-json column="parsed_json"
       --> @dm:save name="temp-isis-output"
    --> @exec:end-if

## Now calculate the edges
--> @c:new-block
    --> @dm:recall name="temp-isis-output" and return_empty="yes"
    --> @dm:skip-block-if-shape row_count = 0
    --> @dm:enrich dict="temp-nodes"
            and src_key_cols="source_ip"
            and dict_key_cols="device_ip"
            and enrich_cols="node_id,node_label,org_id,latitude,longitude"
            and enrich_cols_as="left_id,left_label,org_id,latitude,longitude" &  return_empty_dict = "yes" & return_empty_cols = "yes"
    --> @dm:enrich dict="temp-nodes"
            and src_key_cols="system_id"
            and dict_key_cols="device_hostname_short"
            and enrich_cols="node_id,node_label,device_ip"
            and enrich_cols_as="right_id,right_label,remote_ip" &  return_empty_dict = "yes" & return_empty_cols = "yes"
    ## Hack to overcome a limitation in isis output where we dont know the local interface.
    ## do a self enrichment to find the remote device's remote interface and make it a local interface.
    ## This works only if there is only one ISIS link between the same devices.
    --> @dm:save name="temp-isis-edges"
    --> @dm:eval left_id_orig="left_id" and right_id_orig="right_id"
    --> @dm:enrich dict="temp-isis-edges" and src_key_cols="left_id_orig,right_id_orig" and dict_key_cols="right_id,left_id" and enrich_cols="interface_full_name" and enrich_cols_as="local_interface" and cache="no" &  return_empty_dict = "yes" & return_empty_cols = "yes"
    --> @dm:add-missing-columns columns="local_interface"
    --> @dm:eval left_id="left_id_orig" and right_id="right_id_orig"
    ## End Hack
    ## Setting edge columns
    --> @dm:eval left_node_type = "'CHASSIS'" and
            right_node_type = "'CHASSIS'" and
            link_type = "'ISIS'" and
            relation_type = "'connected-to'" and
            left_ip="source_ip" and
            right_ip ="remote_ip" and
            local_interface="local_interface or 'UNKNOWN'" and
            neighbor_interface="interface_full_name or 'UNKNOWN'" and
            remote_hostname="right_label" and
            showAttrs="'^ietf_nsf$|^holdtime$|^state$|^snpa$|^local_ip$|^local_interface$|^remote_ip$|^neighbor_interface$|^remote_platform$|^remote_hostname$|^remote_version$'" and
            direction = "'NO_DIRECTION'" and
            style_color="'#4DD0E1'" and
            style_width="'2'" and
            sorted_arr="[f'{left_id}_{local_interface}',f'{right_id}_{neighbor_interface}']" and
            unique_id="':'.join(sorted(sorted_arr)) + str(link_type)"
    --> @dm:dedup columns="unique_id"
    --> *dm:filter left_id is not Empty
    --> *dm:filter right_id is not Empty
    --> *dm:filter left_id != right_id
    --> @dm:fixnull columns="left_id,right_id,local_interface,neighbor_interface,link_type" and value="None"
    --> *dm:filter left_id is not Empty
    --> *dm:filter right_id is not Empty
    --> @dm:selectcolumns include="^customer_id$|^customer_tag$|^ietf_nsf$|^holdtime$|^state$|^snpa$|^left_id$|^left_label$|^right_id$|^right_label$|^left_node_type$|^right_node_type$|^link_type$|^relation_type$|^local_ip$|^local_interface$|^neighbor_interface$|^remote_hostname$|^showAttrs$|^direction$|^style_color$|^style_width$|^unique_id$|^left_ip$|^right_ip$|^latitude$|^longitude$"
    --> @dm:selectcolumns exclude="sorted_arr|^left_id_orig$|^right_id_orig$"
    --> *dm:filter link_type is not empty
    --> *dm:filter left_id is not Empty
    --> *dm:filter right_id is not Empty
    --> *dm:filter left_id != right_id
    --> @dm:save name="temp-edges-isis"
    --> @rn:write-stream name='cfx_rdaf_topology_edges'
    --> @graph:insert-edges dbname = 'cfx_rdaf_topology' & nodes_collection = 'cfx_rdaf_topology_nodes' & edges_collection = 'cfx_rdaf_topology_edges' & left_id = 'left_id' & right_id = 'right_id' & edge_key_attrs = "unique_id" & sort_on_key = true

