%% stream = no and limit = 0

%% import_src_type = "kubernetes-inventory"

## Kubernetes Cluster Inventory##
@exec:get-input
    --> @dm:save name = 'temp-variable-dataset'

## Kubernetes Cluster Topology Nodes
--> @c:data-loop dataset='temp-variable-dataset' & columns = 'ip_address,kubernetes_src_name'
    --> @dm:empty
    --> #dm:query-persistent-stream kube_cluster_name = '$kubernetes_src_name' & asset_object = 'Node' with-input name = 'kubernetes-cluster-inventory' & limit = 0
    --> *exec:if-shape num_rows > 0
       --> @dm:selectcolumns include = '^kube_controller_ip$|^kube_cluster_name$|^kube_cluster_version$|^collection_timestamp$|customer_tag|customer_id'
       --> @dm:dedup columns = 'kube_controller_ip,kube_cluster_name'
       --> @dm:eval layer = "'Kubernetes'"
       --> @dm:eval node_type = "'Kubernetes_Cluster'"
       --> @dm:eval iconURL = "'Cluster'"
       --> @dm:map from = 'kube_cluster_name' & to = 'node_id'
       --> @dm:map from = 'kube_cluster_name' & to = 'node_label'
       --> @dm:save name = 'temp-k8s-cluster-nodes'
       --> @rn:write-stream name =  'cfx_rdaf_topology_nodes'
       --> @graph:insert-nodes dbname = 'cfx_rdaf_topology' & collection = 'cfx_rdaf_topology_nodes' & key_column = 'node_id'
    --> @exec:end-if

## Host OS Inventory Dictionary
--> @c:new-block
    --> @dm:empty
    --> #dm:query-persistent-stream asset_object = 'System' get hostname,host_os_ip,host_bios_uuid,customer_tag,customer_id with-input name = 'host-os-inventory' & max_rows = '5000' & limit = 0 & skip_error = 'yes'
    --> @dm:save name = 'temp-host_os_nodes_dict'

## VMware VM Inventory Dictionary
--> @c:new-block
    --> @dm:empty
    --> #dm:query-persistent-stream asset_object = 'VirtualMachine' get vcenter_address,vm_name,vm_instance_uuid,vm_bios_uuid with-input name = 'vmware-vcenter-inventory' & max_rows = '5000' & limit = 0 & skip_error = 'yes'
    --> @dm:save name = 'temp-vcenter-vm-nodes-dict'

## Baremetal Server Inventory Dictionary
--> @c:new-block
    --> @dm:empty
    --> #dm:query-persistent-stream asset_object = 'Server' get ip_address,hostname,bios_uuid with-input name = 'redfish_server_hardware_inventory' & limit = 0 & skip_error = 'yes'
    --> @dm:save name = 'temp-baremetal_server_nodes_dict'

## ##
## Kubernetes Worker Nodes Topology Nodes + VM / Host OS / Baremetal server Nodes Enrichment
--> @c:data-loop dataset='temp-variable-dataset' & columns = 'ip_address,kubernetes_src_name'
    --> @dm:empty
    --> #dm:query-persistent-stream kube_cluster_name = '$kubernetes_src_name' & asset_object = 'Node' with-input name = 'kubernetes-cluster-inventory' & limit = 0
    --> *exec:if-shape num_rows > 0
       --> @dm:enrich-conditional dict = 'temp-host_os_nodes_dict' & condition = "host_bios_uuid == '$kube_node_bios_uuid' or host_bios_uuid == '$kube_node_bios_uuid_reverse'" & enrich_cols = 'hostname,host_os_ip,host_bios_uuid' & enrich_cols_as = 'host_os_hostname,host_os_ip,host_bios_uuid' & return_empty_dict = 'yes' & return_empty_cols = 'yes'
       --> @dm:enrich-conditional dict = 'temp-vcenter-vm-nodes-dict' & condition = "vm_bios_uuid == '$kube_node_bios_uuid' or vm_bios_uuid == '$kube_node_bios_uuid_reverse'" & enrich_cols = 'vcenter_address,vm_name,vm_instance_uuid' & return_empty_dict = 'yes' & return_empty_cols = 'yes'
       --> @dm:enrich-conditional dict = 'temp-baremetal_server_nodes_dict' & condition = "bios_uuid == '$kube_node_bios_uuid' or bios_uuid == '$kube_node_bios_uuid_reverse'" & enrich_cols = 'ip_address,hostname,bios_uuid' & enrich_cols_as = 'server_hostname,server_ip,server_bios_uuid' & return_empty_dict = 'yes' & return_empty_cols = 'yes'
       --> @dm:map from = 'host_os_hostname,host_os_ip,host_bios_uuid' & to = 'host_os_node_id' & func = 'join' & sep = "_"
       --> @dm:rename-columns host_os_node_label = 'host_os_hostname'
       --> @dm:map from = 'vcenter_address,vm_name,vm_instance_uuid' & to = 'vm_node_id' & func = 'join' & sep = "_"
       --> @dm:rename-columns vm_node_label = 'vm_name'
       --> @dm:map from = 'server_ip,server_bios_uuid' & to = 'server_node_id' & func = 'join' & sep = "_"
       --> @dm:rename-columns server_node_label = 'server_hostname'
       --> @dm:fixnull columns = 'vm_node_label,host_os_node_label,server_node_label' & value = ''
       --> @dm:selectcolumns exclude = '^unique_id$|^host_os_ip$|^host_bios_uuid$|^host_os_hostname$|^vm_name$|^vcenter_address$|^vm_instance_uuid$|^server_ip$|^server_bios_uuid$'
       --> @dm:eval layer = "'Kubernetes'"
       --> @dm:eval node_type = "'Kubernetes_Worker'"
       --> @dm:eval iconURL = "'Host'"
       --> @dm:map from = 'kube_node_ip' & to = 'node_id'
       --> @dm:map from = 'kube_node_hostname' & to = 'node_label'
       --> @dm:save name = 'temp-k8s-worker-nodes'
       --> @dm:selectcolumns exclude = '^vm_node_label$|^host_os_node_label$|^vm_node_id$|^host_os_node_id$|^server_node_id$|^server_node_label$'
       --> @rn:write-stream name =  'cfx_rdaf_topology_nodes'
       --> @graph:insert-nodes dbname = 'cfx_rdaf_topology' & collection = 'cfx_rdaf_topology_nodes' & key_column = 'node_id'
    --> @exec:end-if

## ##
## Kubernetes POD Topology Nodes
--> @c:data-loop dataset='temp-variable-dataset' & columns = 'ip_address,kubernetes_src_name'
    --> @dm:empty
    --> #dm:query-persistent-stream kube_cluster_name = '$kubernetes_src_name' & asset_object = 'POD' with-input name = 'kubernetes-cluster-inventory' & limit = 0
    --> *exec:if-shape num_rows > 0
       --> @dm:eval layer = "'Kubernetes'"
       --> @dm:eval node_type = "'Kubernetes_POD'"
       --> @dm:eval iconURL = "'Container'"
       --> @dm:map from = 'kube_pod_uuid' & to = 'node_id'
       --> @dm:map from = 'kube_pod_name' & to = 'node_label'
       --> @dm:save name = 'temp-k8s-pod-nodes'
       --> @rn:write-stream name =  'cfx_rdaf_topology_nodes'
       --> @graph:insert-nodes dbname = 'cfx_rdaf_topology' & collection = 'cfx_rdaf_topology_nodes' & key_column = 'node_id'
    --> @exec:end-if

## ##
## Kubernetes Topology Edges
## Kubernetes Worker Nodes to VMware VM Relationship
--> @c:new-block
    --> @dm:recall name = 'temp-k8s-worker-nodes' & return_empty = 'yes'
    --> *dm:safe-filter vm_node_label is not empty and host_os_node_label is empty
    --> *exec:if-shape num_rows > 0
       --> *dm:safe-filter * get vm_node_id as 'left_id',vm_node_label as 'left_label',node_id as 'right_id',node_label as 'right_label',node_type as 'right_node_type',customer_tag,customer_id
       --> @dm:eval left_node_type = "'VM'"
       --> @dm:map to = 'relation_type' & func = 'fixed' & value = 'runs'
       --> @dm:save name = 'temp-k8s-worker-to-vm-edges'
    --> @exec:end-if

## Kubernetes Worker Nodes to Host OS Relationship
--> @c:new-block
    --> @dm:recall name = 'temp-k8s-worker-nodes' & return_empty = 'yes'
    --> *dm:safe-filter host_os_node_label is not empty and (vm_node_label is empty or vm_node_label is not empty)
    --> *exec:if-shape num_rows > 0
       --> *dm:safe-filter * get host_os_node_id as 'left_id',host_os_node_label as 'left_label',node_id as 'right_id',node_label as 'right_label',node_type as 'right_node_type',customer_tag,customer_id
       --> @dm:eval left_node_type = "'Host_OS'"
       --> @dm:map to = 'relation_type' & func = 'fixed' & value = 'runs'
       --> @dm:save name = 'temp-k8s-worker-to-host-os-edges'
    --> @exec:end-if

## Kubernetes Worker Nodes to Server Relationship
--> @c:new-block
    --> @dm:recall name = 'temp-k8s-worker-nodes' & return_empty = 'yes'
    --> *dm:safe-filter server_node_label is not empty
    --> *exec:if-shape num_rows > 0
       --> *dm:safe-filter * get server_node_id as 'left_id',server_node_label as 'left_label',node_id as 'right_id',node_label as 'right_label',node_type as 'right_node_type',customer_tag,customer_id
       --> @dm:eval left_node_type = "'Server'"
       --> @dm:map to = 'relation_type' & func = 'fixed' & value = 'runs'
       --> @dm:save name = 'temp-k8s-worker-to-server-edges'
    --> @exec:end-if

## Kubernetes Worker Nodes to Kubernetes Cluster Relationship
--> @c:new-block
    --> @dm:recall name = 'temp-k8s-worker-nodes' & return_empty = 'yes'
    --> *exec:if-shape num_rows > 0
       --> *dm:safe-filter * get kube_cluster_name as 'left_id',node_id as 'right_id',node_label as 'right_label',node_type as 'right_node_type',customer_tag,customer_id
       --> @dm:eval left_node_type = "'Kubernetes_Cluster'"
       --> @dm:eval left_label = "left_id"
       --> @dm:map to = 'relation_type' & func = 'fixed' & value = 'contains'
       --> @dm:save name = 'temp-k8s-worker-to-cluster-edges'
    --> @exec:end-if

## Kubernetes Worker Nodes to Kubernetes PODs Relationship
--> @c:new-block
    --> @dm:recall name = 'temp-k8s-pod-nodes' & return_empty = 'yes'
    --> *exec:if-shape num_rows > 0
       --> *dm:safe-filter * get kube_node_ip as 'left_id',kube_node_hostname as 'left_label',node_id as 'right_id',node_label as 'right_label',node_type as 'right_node_type',customer_tag,customer_id
       --> @dm:eval left_node_type = "'Kubernetes_Worker'"
       --> @dm:map to = 'relation_type' & func = 'fixed' & value = 'runs'
       --> @dm:save name = 'temp-k8s-pods-to-worker-node-edges'
    --> @exec:end-if

## Generate Kubernetes Topology Edges Ingestion ID
--> @c:data-loop dataset='temp-variable-dataset' & columns = 'kubernetes_src_name'
    --> @dm:empty
    --> @dm:addrow inventory_source = '$kubernetes_src_name'
    --> @dm:map to = 'collection_timestamp' & func = 'time_now'
    --> @dm:map from = 'collection_timestamp' & to = 'topology_ingestion_id' & func = 'md5'
    --> @dm:save name = 'temp-topology-edges-ingestion-id-dict'

## ###
## Kubernetes Cluster Topology - Edges
--> @c:data-loop dataset='temp-variable-dataset' & columns = 'kubernetes_src_name'
    --> @dm:concat names = '^temp-k8s-worker-to-cluster-edges$|^temp-k8s-pods-to-worker-node-edges$|^temp-k8s-worker-to-vm-edges$|^temp-k8s-worker-to-host-os-edges$|^temp-k8s-worker-to-server-edges$' & return_empty = 'yes'
    --> *exec:if-shape num_rows > 0
       --> @dm:map attr = 'left_id' & func = 'strip'
       --> @dm:map attr = 'right_id' & func = 'strip'
       --> @dm:map from = 'left_id' & to = 'left'
       --> @dm:map from = 'right_id' & to = 'right'
       --> @dm:eval inventory_source = "'$kubernetes_src_name'"
       --> @dm:map to = 'collection_timestamp' & func = 'time_now'
       --> *dm:filter left_id != right_id
       --> *dm:filter left_label is not empty
       --> *dm:filter right_label is not empty
       --> @dm:dedup columns = 'left_id,right_id'
       --> @dm:enrich dict = 'temp-topology-edges-ingestion-id-dict' & src_key_cols = 'inventory_source' & dict_key_cols = 'inventory_source' & enrich_cols = 'topology_ingestion_id'
       --> *dm:filter * get left_label,left_id,left_node_type,relation_type,right_id,right_label,right_node_type,inventory_source,topology_ingestion_id,collection_timestamp,customer_tag,customer_id
       --> @dm:save name = 'temp-kubernetes-cluster-topology-edges'
       --> @rn:write-stream name =  'cfx_rdaf_topology_edges'
       --> @graph:insert-edges dbname = 'cfx_rdaf_topology' & nodes_collection = 'cfx_rdaf_topology_nodes' & edges_collection = 'cfx_rdaf_topology_edges' & left_id = 'left_id' & right_id = 'right_id'
    --> @exec:end-if

## Delete Stale Kubernetes Topology Edges
--> @c:new-block
    --> @dm:empty
    --> @dm:sleep seconds = 60

## Delete Stale Kubernetes Edges from Pstream
--> @c:new-block
    --> @dm:recall name = 'temp-kubernetes-cluster-topology-edges' & return_empty = 'yes'
    --> *dm:safe-filter topology_ingestion_id is not empty
    --> *exec:if-shape num_rows > 0
       --> @dm:dedup columns = 'topology_ingestion_id'
       --> @exec:for-loop num_rows = 1
          --> #dm:pstream-delete-data-by-query topology_ingestion_id != '{%- raw -%}{{row.topology_ingestion_id}}{%- endraw -%}' & inventory_source = '{%- raw -%}{{row.inventory_source}}{%- endraw -%}' with-input name = 'cfx_rdaf_topology_edges' & timeout = 300
          ## --> #dm:pstream-delete-data-by-query topology_ingestion_id != {{'{{row.topology_ingestion_id}}'}} & inventory_source = {{'{{row.inventory_source}}'}} with-input name = 'cfx_rdaf_topology_edges' & timeout = 300
          --> @dm:save name = 'temp-kubernetes_deleted_edges'
       --> @exec:end-loop
    --> @exec:end-if

## Delete Stale Kubernetes Topology Edges from GraphDB
--> @c:new-block
    --> @dm:recall name = 'temp-kubernetes-cluster-topology-edges' & return_empty = 'yes'
    --> *dm:safe-filter topology_ingestion_id is not empty
    --> *exec:if-shape num_rows > 0
       --> @dm:dedup columns = 'topology_ingestion_id'
       --> @exec:for-loop num_rows = 1
          ## --> @graph:delete-by-query dbname = 'cfx_rdaf_topology' & collection = 'cfx_rdaf_topology_edges' & delete_query = "topology_ingestion_id != {{'{{row.topology_ingestion_id}}'}} & inventory_source = {{'{{row.inventory_source}}'}}"
          --> @graph:delete-by-query dbname = 'cfx_rdaf_topology' & collection = 'cfx_rdaf_topology_edges' & delete_query = "topology_ingestion_id != '{%- raw -%}{{row.topology_ingestion_id}}{%- endraw -%}' & inventory_source = '{%- raw -%}{{row.inventory_source}}{%- endraw -%}'"
          --> @dm:save name = 'temp-kubernetes_deleted_edges_from_graphdb'
       --> @exec:end-loop
    --> @exec:end-if

